[{"C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\index.js":"1","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\reportWebVitals.js":"2","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\App.js":"3","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\Board.js":"4","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\Square.js":"5","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\Squares.js":"6","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\RulesModal.js":"7","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\EditBoardModal.js":"8"},{"size":547,"mtime":1607394095915,"results":"9","hashOfConfig":"10"},{"size":362,"mtime":499162500000,"results":"11","hashOfConfig":"10"},{"size":3277,"mtime":1607418832027,"results":"12","hashOfConfig":"10"},{"size":18309,"mtime":1607429368946,"results":"13","hashOfConfig":"10"},{"size":744,"mtime":1607343911953,"results":"14","hashOfConfig":"10"},{"size":416,"mtime":1607342232240,"results":"15","hashOfConfig":"10"},{"size":1911,"mtime":1607419534173,"results":"16","hashOfConfig":"10"},{"size":1664,"mtime":1607429406689,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"1xr1fhv",{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"20"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"20"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"20"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\index.js",[],["38","39"],"C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\reportWebVitals.js",[],"C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\App.js",["40"],"import React, { useEffect, useState } from \"react\";\nimport Board from \"./Board\";\nimport \"./App.css\";\nimport RulesModal from \"./RulesModal\";\nimport EditBoardModal from \"./EditBoardModal\";\nimport { Button } from \"reactstrap\";\n\nfunction App() {\n  const [gameBoardProps, setGameBoardProps] = useState({\n    width: 10,\n    height: 10,\n    totalBombs: 6,\n  });\n  const [endGameText, setEndGameText] = useState();\n  const { width, height, totalBombs } = gameBoardProps;\n  const [showPlayAgainButton, setShowPlayAgainButton] = useState(false);\n  const [isRulesModalOpen, setIsRulesModalOpen] = useState(false);\n  const [isEditBoardModalOpen, setEditBoardModalOpen] = useState(false);\n\n  const handleGameEnd = (playerWon) => {\n    if (playerWon) {\n      console.log(\"you won???\");\n      setEndGameText(\"You Won!\");\n      setShowPlayAgainButton(true);\n      return;\n    }\n    setEndGameText(\"You lost!\");\n    setShowPlayAgainButton(true);\n  };\n\n  const toggleRulesModal = (isOpen) => {\n    setIsRulesModalOpen(isOpen);\n  };\n\n  const toggleEditBoardModal = (isOpen) => {\n    setEditBoardModalOpen(isOpen);\n  };\n\n  const handleEditSubmit = (updatedBombs, updatedBoardSize) => {\n    setGameBoardProps({\n      width: updatedBoardSize,\n      height: updatedBoardSize,\n      totalBombs: updatedBombs,\n    });\n  };\n\n  return (\n    <>\n      <div\n        style={{\n          display: \"flex\",\n          justifyContent: \"center\",\n        }}\n      >\n        <div>\n          <h1 style={{ textAlign: \"center\" }}>MINESWEEPER</h1>\n          <div>\n            <Board\n              width={height}\n              height={width}\n              totalBombs={totalBombs}\n              handleGameEnd={handleGameEnd}\n              showPlayAgainButton={showPlayAgainButton}\n              togglePlayAgainButton={(show) => setShowPlayAgainButton(show)}\n              toggleEndGameText={(value) => setEndGameText(value)}\n              endGameText={endGameText}\n            ></Board>\n          </div>\n          <div\n            style={{\n              display: \"flex\",\n              justifyContent: \"space-between\",\n              alignItems: \"flex-start\",\n            }}\n          >\n            <div style={{ marginTop: \"15px\" }}>\n              <span>\n                <Button color=\"primary\" onClick={() => toggleRulesModal(true)}>\n                  Rules\n                </Button>\n              </span>\n\n              <Button\n                color=\"primary\"\n                onClick={() => toggleEditBoardModal(true)}\n              >\n                Edit Board\n              </Button>\n              <div>\n                <h5>\n                  {`Grid Size: ${gameBoardProps.width} x ${gameBoardProps.width}`}\n                </h5>\n                <h5>{`Bomb Total: ${gameBoardProps.totalBombs}`}</h5>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      {isRulesModalOpen && (\n        <RulesModal isOpen={isRulesModalOpen} toggle={toggleRulesModal} />\n      )}\n      {isEditBoardModalOpen && (\n        <EditBoardModal\n          isOpen={isEditBoardModalOpen}\n          toggle={toggleEditBoardModal}\n          size={gameBoardProps.width}\n          totalBombs={gameBoardProps.totalBombs}\n          handleSubmit={handleEditSubmit}\n        />\n      )}\n    </>\n  );\n}\n\nexport default App;\n","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\Board.js",["41","42","43","44","45","46"],"import React, { useState, useEffect } from \"react\";\r\nimport Square from \"./Square\";\r\nimport Squares from \"./Squares\";\r\nimport { Button } from \"reactstrap\";\r\nimport { render } from \"react-dom\";\r\n\r\nlet tempSquareArray = [];\r\nlet tempCheckGrid = [];\r\n\r\n//Main board component\r\nclass Board extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      gameBoardProps: {\r\n        width: this.props.height,\r\n        height: this.props.width,\r\n        totalBombs: this.props.totalBombs,\r\n        flags: 0,\r\n      },\r\n      isGameOver: false,\r\n      squares: [],\r\n      checkForWinVisitedSquares: [],\r\n    };\r\n  }\r\n\r\n  //First initialization of game board\r\n  componentDidMount() {\r\n    this.initializeGameBoard();\r\n  }\r\n\r\n  //Handles update to total bombs by a user. If the total bombs changes it re-initializes the board by calling handleStartNewGame\r\n  componentDidUpdate(prevProps, prevState) {\r\n    if (\r\n      prevProps.totalBombs !== this.props.totalBombs ||\r\n      prevProps.width !== this.props.width\r\n    ) {\r\n      this.handleStartNewGame();\r\n    }\r\n  }\r\n\r\n  //Resets the game state and initializes a new game board. Used for when the player plays games after the first\r\n  handleStartNewGame = () => {\r\n    this.setState(\r\n      {\r\n        gameBoardProps: {\r\n          width: this.props.height,\r\n          height: this.props.width,\r\n          totalBombs: this.props.mines,\r\n          flags: 0,\r\n        },\r\n        squares: [],\r\n        checkForWinVisitedSquares: [],\r\n        isGameOver: false,\r\n      },\r\n      () => this.initializeGameBoard()\r\n    );\r\n  };\r\n\r\n  //Checks to see if a border square contains a bomb\r\n  borderSquareContainsBomb = (direction, currIndex, gameSquares) => {\r\n    return this.containsBomb(\r\n      gameSquares[this.borderSquareIndex(direction, currIndex)]\r\n    );\r\n  };\r\n\r\n  //Main function for initialization a game board. Is responsible for randomizing the squares with bombs/no bombs\r\n  initializeGameBoard = () => {\r\n    const { width, totalBombs } = this.props;\r\n    const bombsBoard = new Array(totalBombs).fill(\"bomb\");\r\n    const emptyBoard = Array(width * width - totalBombs).fill(\"valid\");\r\n    const gameArray = [...emptyBoard, ...bombsBoard];\r\n    const randomGameBoard = gameArray.sort(() => Math.random() - 0.5);\r\n\r\n    const gameSquares = [];\r\n    for (let i = 0; i < width * width; i++) {\r\n      const square = {\r\n        squareType: randomGameBoard[i],\r\n        id: i,\r\n        total: 0,\r\n        checked: false,\r\n        flagged: false,\r\n        text: undefined,\r\n      };\r\n      gameSquares.push(square);\r\n    }\r\n\r\n    for (let i = 0; i < gameSquares.length; i++) {\r\n      let total = 0;\r\n\r\n      const isLeftEdge = i % width === 0;\r\n      const isRightEdge = (i + 1) % width === 0;\r\n      const isTop = i < width;\r\n      const isBottom = i > width * width - width - 1;\r\n      if (gameSquares[i].squareType === \"valid\") {\r\n        if (\r\n          !isLeftEdge &&\r\n          this.borderSquareContainsBomb(\"west\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        if (\r\n          !isRightEdge &&\r\n          this.borderSquareContainsBomb(\"east\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        if (\r\n          !isTop &&\r\n          !isRightEdge &&\r\n          this.borderSquareContainsBomb(\"northeast\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        if (!isTop && this.borderSquareContainsBomb(\"north\", i, gameSquares)) {\r\n          total++;\r\n        }\r\n        if (\r\n          !isTop &&\r\n          !isLeftEdge &&\r\n          this.borderSquareContainsBomb(\"northwest\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        if (\r\n          !isBottom &&\r\n          this.borderSquareContainsBomb(\"south\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        if (\r\n          !isBottom &&\r\n          !isLeftEdge &&\r\n          this.borderSquareContainsBomb(\"southwest\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        if (\r\n          !isBottom &&\r\n          !isRightEdge &&\r\n          this.borderSquareContainsBomb(\"southeast\", i, gameSquares)\r\n        ) {\r\n          total++;\r\n        }\r\n        gameSquares[i].total = total;\r\n      }\r\n    }\r\n\r\n    this.setState({\r\n      squares: gameSquares,\r\n    });\r\n  };\r\n\r\n  containsBomb(square) {\r\n    return square.squareType === \"bomb\";\r\n  }\r\n\r\n  //Helps traverse the index of the board. Accounts for outer edges of the grid\r\n  borderSquareIndex = (direction, currIndex) => {\r\n    const { width } = this.props;\r\n    switch (direction) {\r\n      case \"west\":\r\n        return currIndex - 1;\r\n      case \"east\":\r\n        return currIndex + 1;\r\n      case \"north\":\r\n        return currIndex - width;\r\n      case \"south\":\r\n        return currIndex + width;\r\n      case \"northwest\":\r\n        return currIndex - 1 - width;\r\n      case \"northeast\":\r\n        return currIndex + 1 - width;\r\n      case \"southwest\":\r\n        return currIndex - 1 + width;\r\n      case \"southeast\":\r\n        return currIndex + 1 + width;\r\n    }\r\n  };\r\n\r\n  //check neighboring squares once square is clicked\r\n  checkSquare = (square, updatedSquares, currentId) => {\r\n    const { width } = this.props;\r\n    const isLeftEdge = currentId % width === 0;\r\n    const isRightEdge = currentId % width === width - 1;\r\n    const isTop = currentId < width;\r\n    const isBottom = currentId > width * width - width - 1;\r\n\r\n    setTimeout(() => {\r\n      if (!isLeftEdge) {\r\n        this.checkNextSquare(\"west\", currentId, updatedSquares);\r\n      }\r\n      if (!isRightEdge) {\r\n        this.checkNextSquare(\"east\", currentId, updatedSquares);\r\n      }\r\n      if (!isTop) {\r\n        this.checkNextSquare(\"north\", currentId, updatedSquares);\r\n      }\r\n      if (!isTop && !isLeftEdge) {\r\n        this.checkNextSquare(\"northwest\", currentId, updatedSquares);\r\n      }\r\n      if (!isTop && !isRightEdge) {\r\n        this.checkNextSquare(\"northeast\", currentId, updatedSquares);\r\n      }\r\n      if (!isBottom) {\r\n        this.checkNextSquare(\"south\", currentId, updatedSquares);\r\n      }\r\n      if (!isBottom && !isLeftEdge) {\r\n        this.checkNextSquare(\"southwest\", currentId, updatedSquares);\r\n      }\r\n      if (!isBottom && !isRightEdge) {\r\n        this.checkNextSquare(\"southeast\", currentId, updatedSquares);\r\n      }\r\n    }, 5);\r\n  };\r\n\r\n  ////**** BRUTE FORCE METHODS BEGIN */\r\n  //Attempt at creating a 'solution' algorithm. Performs BFS on each square, guarenteeing you will find a solution regardless of the game state.\r\n  solveWithBruteForce(initialValue = 0) {\r\n    let solveByBruteForceArray = [...this.state.squares];\r\n    tempSquareArray = solveByBruteForceArray;\r\n    for (let i = 0; i < this.state.squares.length; i++) {\r\n      const initialSquare = { ...solveByBruteForceArray[i] };\r\n      this.solveWithBruteForceHelper(\r\n        initialSquare,\r\n        solveByBruteForceArray,\r\n        initialSquare.id\r\n      );\r\n    }\r\n    this.setState(\r\n      {\r\n        squares: tempSquareArray,\r\n      },\r\n      () => this.handleCheckForWin()\r\n    );\r\n  }\r\n\r\n  //Brute force helper method\r\n  solveWithBruteForceHelper = (square, solveByBruteForceArray, id) => {\r\n    if (\r\n      solveByBruteForceArray[square.id].checked ||\r\n      solveByBruteForceArray[square.id].squareType === \"bomb\"\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    let squareCopy = { ...solveByBruteForceArray[square.id] };\r\n    if (squareCopy.squareType === \"valid\") {\r\n      squareCopy.checked = true;\r\n    }\r\n    solveByBruteForceArray[square.id] = squareCopy;\r\n\r\n    this.checkSquareForBruteForceSolution(\r\n      squareCopy,\r\n      solveByBruteForceArray,\r\n      square.id\r\n    );\r\n  };\r\n\r\n  //Checks adjacent squares in the brute force solution, helper method\r\n  checkNextSquareForBruteForceSolution = (\r\n    direction,\r\n    currentId,\r\n    solveByBruteForceArray\r\n  ) => {\r\n    const newId = this.borderSquareIndex(direction, parseInt(currentId));\r\n    const square = { ...solveByBruteForceArray[newId] };\r\n    this.solveWithBruteForceHelper(square, solveByBruteForceArray, newId);\r\n  };\r\n\r\n  //Initial check in brute force solution\r\n  checkSquareForBruteForceSolution = (\r\n    square,\r\n    solveByBruteForceArray,\r\n    currentId\r\n  ) => {\r\n    const { width } = this.props;\r\n    const isLeftEdge = currentId % width === 0;\r\n    const isRightEdge = currentId % width === width - 1;\r\n    const isTop = currentId < width;\r\n    const isBottom = currentId > width * width - width - 1;\r\n\r\n    if (!isLeftEdge) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"west\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isRightEdge) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"east\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isTop) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"north\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isTop && !isLeftEdge) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"northwest\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isTop && !isRightEdge) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"northeast\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isBottom) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"south\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isBottom && !isLeftEdge) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"southwest\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n    if (!isBottom && !isRightEdge) {\r\n      this.checkNextSquareForBruteForceSolution(\r\n        \"southeast\",\r\n        currentId,\r\n        solveByBruteForceArray\r\n      );\r\n    }\r\n  };\r\n\r\n  ////**** BRUTE FORCE METHODS END */\r\n\r\n  //Checks an square that connects to the previous checked square. Used for checking user inputs. Helps with 'exploading' the grid\r\n  checkNextSquare = (direction, currentId, updatedSquares) => {\r\n    const newId = this.borderSquareIndex(direction, parseInt(currentId));\r\n    const square = { ...updatedSquares[newId] };\r\n    this.handleClickSquareHelper(newId, square, updatedSquares);\r\n  };\r\n\r\n  //Handles a user click input on the grid. Begins BFS process and then checks to see if the user has won the game.\r\n  handleClickSquare = (id) => {\r\n    const { squares, isGameOver } = this.state;\r\n    let updatedSquares = [...squares];\r\n    let square = { ...updatedSquares[id] };\r\n\r\n    if (isGameOver) return;\r\n    if (square.checked || square.flagged) return;\r\n    if (this.containsBomb(square)) {\r\n      this.gameOver(false);\r\n    } else {\r\n      let total = square.total;\r\n      square.checked = true;\r\n      if (total !== 0) {\r\n        square.text = total;\r\n        updatedSquares[id] = square;\r\n        this.setState(\r\n          {\r\n            squares: updatedSquares,\r\n          },\r\n          () => {\r\n            this.handleCheckForWin();\r\n          }\r\n        );\r\n        return;\r\n      } else {\r\n        updatedSquares[id] = square;\r\n      }\r\n      tempSquareArray = updatedSquares;\r\n      this.checkSquare(square, updatedSquares, id);\r\n      setTimeout(\r\n        () =>\r\n          this.setState(\r\n            {\r\n              squares: tempSquareArray,\r\n            },\r\n            () => {\r\n              this.handleCheckForWin();\r\n            }\r\n          ),\r\n        100\r\n      );\r\n    }\r\n  };\r\n\r\n  //Helper method for user clicking a square\r\n  handleClickSquareHelper = (id, square, updatedSquares) => {\r\n    if (square.checked || square.flagged) return;\r\n    if (this.containsBomb(square)) {\r\n      this.gameOver(false);\r\n    } else {\r\n      let total = square.total;\r\n      square.checked = true;\r\n      updatedSquares[id] = square;\r\n      if (total !== 0) {\r\n        square.text = total;\r\n        return;\r\n      }\r\n      this.checkSquare(square, updatedSquares, id);\r\n    }\r\n  };\r\n\r\n  //Performs game over cleanup after a user either won or lost\r\n  gameOver = (didUserWin) => {\r\n    const { squares } = this.state;\r\n    let updatedSquares = [...squares];\r\n\r\n    //show all bomLocations\r\n    updatedSquares.forEach((square) => {\r\n      if (this.containsBomb(square)) {\r\n        square.text = \"💣\";\r\n      }\r\n    });\r\n    this.setState({\r\n      squares: updatedSquares,\r\n      isGameOver: true,\r\n    });\r\n    this.props.handleGameEnd(didUserWin);\r\n  };\r\n\r\n  //Main method to check if a game is complete\r\n  handleCheckForWin = () => {\r\n    const { width } = this.props;\r\n    const { squares } = this.state;\r\n    let checkForWinArray = new Array(width * width).fill({\r\n      isValid: true,\r\n      isChecked: false,\r\n    });\r\n\r\n    tempCheckGrid = checkForWinArray;\r\n    this.checkForWin(squares[0], checkForWinArray, squares[0].id);\r\n    setTimeout(\r\n      () =>\r\n        this.setState(\r\n          {\r\n            checkForWinVisitedSquares: tempCheckGrid,\r\n          },\r\n          () => {\r\n            if (\r\n              this.checkIfCheckWinArrayIsValid(\r\n                this.state.checkForWinVisitedSquares\r\n              )\r\n            ) {\r\n              this.gameOver(true);\r\n            }\r\n          }\r\n        ),\r\n      100\r\n    );\r\n  };\r\n\r\n  // Looks through the 'memo' created when checking a win and figures out if all squares are valid\r\n  checkIfCheckWinArrayIsValid = (checkForWinVisitedSquares) => {\r\n    for (let i = 0; i < checkForWinVisitedSquares.length; i++) {\r\n      if (!checkForWinVisitedSquares[i].isValid) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  //Win verification helper method\r\n  checkForWin = (square, checkForWinArray, id) => {\r\n    if (checkForWinArray[square.id].isChecked) return;\r\n\r\n    let checkedIndexObject = { ...checkForWinArray[square.id] };\r\n    checkedIndexObject.isChecked = true;\r\n    checkForWinArray[square.id] = checkedIndexObject;\r\n\r\n    if (!square.checked && !square.flagged && square.squareType === \"valid\") {\r\n      checkForWinArray[id].isValid = false;\r\n      return;\r\n    }\r\n\r\n    this.checkSquareForSolution(square, checkForWinArray, id);\r\n  };\r\n\r\n  //Win verification helper method\r\n  checkNextSquareForSolution = (direction, currentId, checkForWinArray) => {\r\n    const newId = this.borderSquareIndex(direction, parseInt(currentId));\r\n    const square = { ...this.state.squares[newId] };\r\n    this.checkForWin(square, checkForWinArray, newId);\r\n  };\r\n\r\n  //Win verification helper method\r\n  checkSquareForSolution = (square, checkForWinArray, currentId) => {\r\n    const { width } = this.props;\r\n    const isLeftEdge = currentId % width === 0;\r\n    const isRightEdge = currentId % width === width - 1;\r\n    const isTop = currentId < width;\r\n    const isBottom = currentId > width * width - width - 1;\r\n\r\n    if (!isLeftEdge) {\r\n      this.checkNextSquareForSolution(\"west\", currentId, checkForWinArray);\r\n    }\r\n    if (!isRightEdge) {\r\n      this.checkNextSquareForSolution(\"east\", currentId, checkForWinArray);\r\n    }\r\n    if (!isTop) {\r\n      this.checkNextSquareForSolution(\"north\", currentId, checkForWinArray);\r\n    }\r\n    if (!isTop && !isLeftEdge) {\r\n      this.checkNextSquareForSolution(\"northwest\", currentId, checkForWinArray);\r\n    }\r\n    if (!isTop && !isRightEdge) {\r\n      this.checkNextSquareForSolution(\"northeast\", currentId, checkForWinArray);\r\n    }\r\n    if (!isBottom) {\r\n      this.checkNextSquareForSolution(\"south\", currentId, checkForWinArray);\r\n    }\r\n    if (!isBottom && !isLeftEdge) {\r\n      this.checkNextSquareForSolution(\"southwest\", currentId, checkForWinArray);\r\n    }\r\n    if (!isBottom && !isRightEdge) {\r\n      this.checkNextSquareForSolution(\"southeast\", currentId, checkForWinArray);\r\n    }\r\n  };\r\n\r\n  //Main method for creating the gameboard\r\n  createGameBoard = () => {\r\n    const { width } = this.props;\r\n    const { squares } = this.state;\r\n    const gameBoard = [];\r\n    for (let j = 0; j < width; j++) {\r\n      const squareRow = [];\r\n      for (let i = 0; i < width; i++) {\r\n        const index = j * 10 + i;\r\n        squareRow.push(squares[index]);\r\n      }\r\n      gameBoard.push(squareRow);\r\n    }\r\n\r\n    return gameBoard;\r\n  };\r\n\r\n  //Handles adding or removing a flag from the game board\r\n  addFlag = (id) => {\r\n    const { squares, isGameOver } = this.state;\r\n    let updatedSquares = [...squares];\r\n    let square = { ...updatedSquares[id] };\r\n    if (!square) return;\r\n    if (isGameOver) {\r\n      return;\r\n    }\r\n    if (!square.checked) {\r\n      if (!square.flagged) {\r\n        square.flagged = true;\r\n        square.text = \"🚩\";\r\n        updatedSquares[square.id] = square;\r\n        this.setState({\r\n          squares: updatedSquares,\r\n        });\r\n      } else {\r\n        square.flagged = false;\r\n        square.text = \"\";\r\n        updatedSquares[square.id] = square;\r\n        this.setState({\r\n          squares: updatedSquares,\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { squares } = this.state;\r\n    const { showPlayAgainButton, endGameText } = this.props;\r\n    const gameBoard = this.createGameBoard();\r\n    return (\r\n      <>\r\n        {gameBoard &&\r\n          gameBoard.map((squares, i) => (\r\n            <Squares\r\n              onClick={this.handleClickSquare}\r\n              onContextMenu={this.addFlag}\r\n              squares={squares}\r\n              key={i}\r\n            />\r\n          ))}\r\n        <span style={{ paddingRight: \"10px\" }}>\r\n          <Button color=\"success\" onClick={() => this.solveWithBruteForce()}>\r\n            Solve for me\r\n          </Button>\r\n        </span>\r\n        {/* <span style={{ paddingRight: \"10px\" }}>\r\n          <Button color=\"success\" onClick={() => this.handleCheckForWin()}>\r\n            Check For Win\r\n          </Button>\r\n        </span> */}\r\n        <div>\r\n          <h4>{endGameText}</h4>\r\n          {showPlayAgainButton && (\r\n            <>\r\n              <div\r\n                className={\"play-again-button\"}\r\n                style={{ backgroundColor: \"red\" }}\r\n                onClick={() => {\r\n                  this.handleStartNewGame();\r\n                  this.props.togglePlayAgainButton(false);\r\n                  this.props.toggleEndGameText(undefined);\r\n                }}\r\n              >\r\n                Click to play again!\r\n              </div>\r\n            </>\r\n          )}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\Square.js",["47"],"import React from \"react\";\r\n\r\nfunction Square({ onClick, onContextMenu, squareProps }) {\r\n  if (!squareProps) return null;\r\n  const { id, squareType, checked, flagged, text } = squareProps;\r\n\r\n  const getSquareClasses = () => {\r\n    let squareClasses = \"gameSquare\";\r\n    if (squareType) {\r\n      squareClasses = squareClasses + ` ${squareType}`;\r\n    }\r\n    if (checked) {\r\n      squareClasses = squareClasses + ` checked`;\r\n    }\r\n    return squareClasses;\r\n  };\r\n\r\n  return (\r\n    <div\r\n      onContextMenu={(e) => {\r\n        e.preventDefault();\r\n        onContextMenu(id);\r\n      }}\r\n      id={id}\r\n      onClick={() => onClick(id)}\r\n      className={getSquareClasses()}\r\n    >\r\n      {text}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Square;\r\n","C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\Squares.js",[],"C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\RulesModal.js",[],"C:\\Users\\Zach\\Desktop\\Minesweeper React\\minesweeper\\src\\EditBoardModal.js",["48","49"],{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","severity":1,"message":"55","line":1,"column":17,"nodeType":"56","messageId":"57","endLine":1,"endColumn":26},{"ruleId":"54","severity":1,"message":"58","line":1,"column":17,"nodeType":"56","messageId":"57","endLine":1,"endColumn":25},{"ruleId":"54","severity":1,"message":"55","line":1,"column":27,"nodeType":"56","messageId":"57","endLine":1,"endColumn":36},{"ruleId":"54","severity":1,"message":"59","line":2,"column":8,"nodeType":"56","messageId":"57","endLine":2,"endColumn":14},{"ruleId":"54","severity":1,"message":"60","line":5,"column":10,"nodeType":"56","messageId":"57","endLine":5,"endColumn":16},{"ruleId":"61","severity":1,"message":"62","line":161,"column":5,"nodeType":"63","messageId":"64","endLine":178,"endColumn":6},{"ruleId":"54","severity":1,"message":"65","line":574,"column":13,"nodeType":"56","messageId":"57","endLine":574,"endColumn":20},{"ruleId":"54","severity":1,"message":"66","line":5,"column":36,"nodeType":"56","messageId":"57","endLine":5,"endColumn":43},{"ruleId":"54","severity":1,"message":"55","line":1,"column":17,"nodeType":"56","messageId":"57","endLine":1,"endColumn":26},{"ruleId":"54","severity":1,"message":"67","line":17,"column":9,"nodeType":"56","messageId":"57","endLine":17,"endColumn":22},"no-native-reassign",["68"],"no-negated-in-lhs",["69"],"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","'Square' is defined but never used.","'render' is defined but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","'squares' is assigned a value but never used.","'flagged' is assigned a value but never used.","'onSizeChanged' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]